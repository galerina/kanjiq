angular.module('kanjiApp').factory('search', ['$http', '$q', 'kanjiDictionary', 'wordDictionary', 'textUtil',
                                    function($http, $q, kanjiDictionary, wordDictionary, textUtil) {
    var kanjiLookup,kanjiFeatures;

    $http.get('data/kanjiLookup.json').success(function(data) {
        kanjiLookup = data;
        kanjiFeatures = Object.keys(data).sort();
        ready();
    });

    var ready = _.after(2, function() {
        onReadyFunction();
    });

    // Given a list of arrays, generate all sequences that can be generated by using
    // exactly one element of each of the arrays.
    var generateAllSequences = function(arrays) {
        var sequences = [[]];

        arrays.forEach(function(array) {
            var newSequences = [];
            array.forEach(function(elem) {
                sequences.forEach(function(sequence) {
                    newSequences.push(sequence.concat(elem))
                });
            });

            sequences = newSequences;
        });

        return sequences.map(function(s) {
            return _.uniq(s);
        });
    };


    var generateAllQueryArrays = function(query) {
        var alternates = [];
        tokenize(query).forEach(function(token) {
            var possibilities = [token];
            if (_.has(kanjiLookup["meaningTable"], token)) {
                kanjiLookup["meaningTable"][token].forEach(function(kanji) {
                    possibilities.push(kanjiDictionary.getRadicals(kanji));
                });
            } else if (textUtil.isKanji(token)) {
                var radicals = kanjiDictionary.getRadicals(token);
                if (radicals.length > 1) {
                    possibilities.push(radicals);
                }
            }

            alternates.push(possibilities);
        });

        return generateAllSequences(alternates);
    };

    var tokenize = function(query) {
        var tokenRE = /(?:([^"'\s]+)\s*)|(?:"([^"']+)"\s*)|(?:'([^"']+)'\s*)/g;

        var match;
        var tokens = [];
        var lastIndex = 0;
        query = query.trim();
        while (match = tokenRE.exec(query)) {
            if (match.index != lastIndex) {
                break;
            }
            tokens.push(match[1] || match[2] || match[3]);
            lastIndex = tokenRE.lastIndex;
        }
        return tokens;
    };

    var unionOfSortedArrays = function(arrays) {
       if (_.isEmpty(arrays)) {
            return [];
        } else if (arrays.length == 1) {
            return arrays[0];
        }

        var cursors = [];
        for (var i = 0; i < arrays.length; i++) {
            cursors.push(0);
        }

        var out = []

        for (var j = 0; j < arrays[0].length; j++) {
            for (var i = 1; i < arrays.length; i++) {
                while (cursors[i] < arrays[i].length && arrays[i][cursors[i]] < arrays[0][j]) {
                    cursors[i]++;
                }

                if (cursors[i] == arrays[i].length) {
                    return out;
                }
            }

            var isCommonElement = true;
            for (var i = 1; i < arrays.length; i++) {
                if (arrays[0][j] != arrays[i][cursors[i]]) {
                    isCommonElement = false;
                    break;
                }
            }

            if (isCommonElement) {
                out.push(arrays[0][j]);
            }
        }
        return out;
    };


    var obj = {};
    obj.findKanji = function(query) {
        var promise = {};
        promise.then = function(callback) {
            if (_.isEmpty(query)) {
                return callback([]);
            }

            var results = [];

            generateAllQueryArrays(query).forEach(function(q) {
                var newResults = unionOfSortedArrays(q.map(function(token) {
                    return kanjiLookup['radicalTable'][token] || kanjiLookup['meaningTable'][token] || [];
                }));
                Array.prototype.push.apply(results, newResults);
            });

            return callback(_.uniq(results));
        }

        return promise;
    };

    obj.findWords = function(query) {
        var promise = {};
        promise.then = function(callback) {
            if (_.isEmpty(query)) {
                return callback([]);
            }

            var kanjiPromises = query.split("+").map(function(queryPart) {
                if (textUtil.isJapaneseText(queryPart)) {
                    return {
                        then: function(callback) {
                            callback([queryPart]);
                        }
                    }
                } else {
                    return obj.findKanji(queryPart);
                }
            });

            $q.all(kanjiPromises).then(function(queryParts) {
                var results = [];
                var wordPromises = [];
                generateAllSequences(queryParts).forEach(function(sequence) {
                    var prefix = sequence.join("");
                    wordPromises.push(wordDictionary.wordsMatchingPrefix(prefix));
                });

                $q.all(wordPromises).then(function(words) {
                    callback(_.uniq(_.flatten(words)).sort());
                });
            });
        };
        return promise
    };

    obj.onReady = function(fn) {
        onReadyFunction = fn;
        ready();
    };

    return obj;
}]);